# Chapter 12. 다형성


> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; / &nbsp; 조영호 저자 &nbsp; / &nbsp; 위키북스
> * 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)
    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)
> * 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
> * 책의 내용과 다릅니다.
>


#### reference
* [저자 조영호 님 github](https://github.com/eternity-oop/object)


<br>


* 참고
  * [JVM_ref_d2.naver](https://d2.naver.com/helloworld/1230)

<br>


* 책 ch12는 다형성의 주제로 한 과정들을 단계별로 설명 되어 있습니다.
  * 자바의 프로그래밍 언어에 국한한 개념이 아니라, 메커니즘 접근으로 다양한 언어에서의 메시지 수신 방식의 예제들이 정말 좋았는데요.
  * 이해한 내용을 토대로 JVM에 의한 인스턴스와 클래스 메모리영역의 과정을 정리해 보면 좋을 것 같았습니다.



* 책에서 제가 주요하게 잡은 포인트는 아래와 같습니다.
  * "런타임" 이란?
  *  "self 참조"와 super 참조차이 &#8594; "위임"

* 책의 내용에서 차이를 두며 객체지향적으로 생각해볼 것들은 아래와 같습니다.
  * 객체 vs 클래스
  * 호출 vs 전송

<br>

---

<br>

먼저 JVM 에 대한 그림자료는 상단에 `참고`에 쓰여진 사이트에서 참고하여 첨부 했습니다. <br>


* **자바는 동적 로드**, 즉 컴파일타임이 아니라 **런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크**하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다.  

<br>


<img src="https://user-images.githubusercontent.com/66774973/139875692-d909b6a1-7b81-4ddd-9379-99221de65f4e.PNG" width="300">  <br>

* 상단의 그림에서 클래스 로더 진행으로 JVM이라는 프로그램이 운영체제 위에서 실행되면서 런타임 데이터 영역이 메모리에 할당된다. <br>

<img src="https://user-images.githubusercontent.com/66774973/139876682-136b7f7a-d201-43c8-a812-14186d9c678f.PNG" width="300">

<br>

* 여기서 Heap 영역에 생성된 인스턴스가 놓이고, 사용되지 않는 일정시간이 지나면 GC에 의해 해제된다.
* Method Area 가 아래 그림에서 class 포인터에 의해 참조되어지는 곳이다. (p.409)

<br>

<img src="https://user-images.githubusercontent.com/66774973/139877846-0f7a74f6-e953-45ff-9ec2-e6a79fa35878.PNG" width="400">

<br>

* 즉 실제 모두 `런타임`에 작동되는 인스턴스와 class 포인터에 의해 지칭 클래스들에서 메서드 탐색이 일어납니다.
  * (앞 장에서 런타임과 컴파일에 대해 언급도 있었으니 참고바랍니다.) 여기서 저는 `런타임`에 대해 자바 프로그래밍 언어를 비추어서 정리하고자 합니다.
    * 그림에서 보이듯이, 자바 소스가 컴파일러에 의해 자바바이트코드로 컴파일 된 후 JVM 에서 실행됩니다.
    * JVM의 클래스 로더 이후 부터가 런타임 상태 이구요.
  * Heap 영역 - self 참조에 의해 포인터 되는 인스턴스 메모리 영역
    * 교재 : 객체의 데이터 영역으로, 각각의 인스턴스별로 가질 상태 정보를 위해 독립적으로 할당되어져야 한다.
  * Method area - class 포인터에 의해 메서드 탐색이 일어나는 곳
    * 교재 : 한번만 로드되어져 동일 클래스의 인스턴스들간에 메서드 공유하는 공간
  * **두 영역의 차이는 객체와 클래스의 차이가 있다.**
    * new 생성자로 인해 생성되는 시점이 각각 다른 인스턴스(객체)는 Heap 영역에 있으며, 일정 시간 지난 후 GC에 의해 해제된다. (효율적 자원관리)
    * 프로그램이 실행되는(클래스로더) 때부터 프로그램이 종료 될때까지 시스템 내 모든 클래스들(static 등)은 한 번 로드되어 공통의 클래스 인스턴스들 간에 공유된다.
  * 인스턴스의 생성시 `this` 가 해당 클래스 내의 생성자 포함한 모든 메서드에 자동 부착되어진다. (self 참조 생성)
    * `런타임`시 필요된 시점에 생성된 인스턴스(`self 참조` = this)는 요청받은 메시지를 수신할 메서드의 탐색이 일어난다.



* 필요시점에 생성되어(런타임) 처음 요청받은 인스턴스를 통해서만 상속관계의 역방향으로 메서드 탐색이 일어납니다.
  * ex : GradeLecture &#8594; Lecture &#8594; Object
  * 메서드 탐색시 자동으로 탐색경로가 되어지는 자식 &#8594; 부모 위임에 대해 생각해 봅시다.
    * `super` 예약어를 통해 부모로 데이터를 전달하거나 메서드를 실행시킨다.
      * 부모 데이터 에서부터 시작한다.
    * `self 참조`는 생성된 인스턴스에서 부터 시작한다.
      * 위임과 포워드의 가장 큰 차이점
      * 내 클래스 안에 필드로 다른 객체 클래스를 가지고서 (합성) 다른 객체로 메시지 전달하듯이
      * self 참조를 통해 메시지 전송이 가능하다.
    * **호출과 메시지 전송은 다르다.**
      * 호출은 객체를 통해 해당 메서드를 실행시킨다.
      * 메시지 전송은 메시지를 수신할 객체의 탐색과정이 일어난다.
        * 수신할 객체는 컴파일관점에 명확하게 드러나 있지 않다.
        * 런타임시 = 생성된 인스턴스를 시작점으로 self 참조를 통해 메서드의 탐색이 일어난다. 


<br>

몇 가지 예들로 설명을 해보고자 합니다. <br>

* **선언된 참조타입**과 무관하게 **메시지 수신객체 타입**의 실행 메서드가 결정된다.
  * 업캐스팅과 동적바인딩
  * 간단히 설명 하자면
    * 업캐스팅시 선언된 참조 타입의 메서드 코드 선언은 컴파일 시점에 에러가 발생하지 않는다. (자바는 정적타입으로 컴파일 시점에 메서드 탐색결과를 알 수 있다.)
      * 선언된 참조 타입이 아닌, 자식 클래스의 메서드 등을 사용하고자 하면 컴파일 에러 발생
      * 예전에 자바 기본서에서 업캐스팅 관련하여 왜 사용하지 못할 자식클래스의 메모리 할당이 있는지 의문이었어요. != 타입캐스팅 
    * 단, 자식클래스의 메서드가 코드에 <u>명시적 선언 없이</u> 실행될 수 있는데, (컴파일 관점)
      * 상속관계의 자식클래스에 오버라이딩된 메서드가 우선순위를 갖고 자동으로 실행된다. (시그니처 일치)
      * 이점이, 객체로서 (선언된 참조타입이 아닌 new로 생성된 인스턴스 &#8594; self 참조를 통한) 호출이 아닌 메시지 수신자가 되는 차이가 되어진다.
  ``` java
    Lecture lecture = new GradeLecture();
    lecture.evaluate();    // 오버라이딩
    lecture.average();     // GradeLecture 는 average( gradeName ) 으로 오버로딩
  ```

  * 동적 바인딩
    * 컴파일되면서 우선순위를 매겨놨을까? 로 저만 생각햇을까요..
      * 그러면 하드코딩일 거 같은데
    * 클래스는 한 번만 로드 됩니다.
    * 복잡하게 우선순위들로 다양한 객체들과 협력하도록 쉽진 않을 텐데요.
    * "탐색" 과정과 "메시지 전송"으로 쉽게 이해되어 졌습니다.
      * self 참조는 생성된 인스턴스를 포인터로 가지고 있습니다.
      * 생성된 인스턴스가 자식클래스라면, 해당 자식클래스부터 메서드 탐색이 일어납니다.
      * 동일한 시그니처로 자식클래스에 쓰이지 않는다면 프로그래밍상 부모 코드를 쓰겠죠.
        * 오버라이딩으로 자식클래스는 별도로 가지고 있고,
        * 동일 메시지 요청으로도 생성된 인스턴스에 의해 자식클래스의 메서드를 먼저 탐색하게 됩니다.
          * 업캐스팅으로 선언됨 참조 타입이 부모인 것과 무관하게 수신객체 타입의 실행 메서드가 결정되어 집니다. 
          * 실행될 메서드는 stack 구조로 쌓여서 순서대로 실행되게 하겠죠. 그러면, 간단하게만 봐도 stack 으로 실행할 메서드를 보낸 후, 다음 메서드의 실행은 단순하게 부모 클래스에서 탐색할까요?
    * 생성된 인스턴스의 self 참조로 해당 클래스부터 탐색시 처리 후 다음 수신 메시지가 부모 클래스에 있다면?
      * 부모 클래스도 자동탐색과정이 일어나는데요
      * 이때 super 예약어가 아닌, self 참조를 통해 자식클래스부터 재탐색이 시작됩니다. 
      * 여기서 **위임**과 포워딩의 차이를 교재에서 언급하고 자세히 설명 해주셨어요. (p.428)


<br>


* 2차원 구조의 메모리에서 JVM의 실행과정과 프로그래밍 코드를 연결지어보면서 시간 할애를 많이 한 만큼 정말 재밌었어요.
  * 결론은 **객체를 지향하는 것으로 메시지와 협력 하는 것** 이 주제입니다.






  
