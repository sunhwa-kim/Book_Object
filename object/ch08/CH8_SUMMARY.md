# Chapter 10. 상속과 코드 재사용


> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; / &nbsp; 조영호 저자 &nbsp; / &nbsp; 위키북스
> * 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)
    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)
> * 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
> * 책의 내용과 다릅니다.
>


## reference


* [저자 조영호 님 github](https://github.com/eternity-oop/object)



<br>

---


### 🌼 협력적이면서도 유연한 객체를 만들기 위해 의존성 관리 방법을 살펴보자.
객체지향 설계란 의존성을 관리하고, 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술


#### 잘 설계된 객체지향 애플리케이션
* `응집도 높은` 객체들 구성으로 `책임이 명확`하고 `한 가지 일`만 잘하는 객체
* 애플리케이션 기능 구현을 위해 다른 객체에게 도움 요청해야하고, 이런 요청이 `객체간의 협력`을 낳는다.


#### 협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠뜨린다.
* 다른 객체와 협력하기 위해 객체의 존재를 알아야 하고, 객체가 수신할 메시지도 알아야 한다.
  * 이런 지식이 객체 간에 의존성을 낳는다.
  * 과도한 의존성은 수정하기 어렵게 만든다.
* 협력을 위해 의존성을 유지하면서 변경을 방해하는 의존성은 제거해야 한다.


<br>

* **의존성** : `의존하는 대상`의 변경에 영향을 받을 수 있는 `가능성`
  * 방향성을 가진다. - 항상 `단방향`
  * 실행시점 - 의존 객체들의 정상 동작위해, 실행시 대상객체 반드지 존재해야 한다.
    * **두 객체 사이에 의존성 존재한다.** - 객체가 예정된 작업의 정상적 수행위해 다른 객체 필요시
  * 구현시점 - 의존 대상 객체의 변경 &#8594; 의존 객체도 변경
* 의존되는 요소의 변경은 의존하는 요소도 함께 변경될 수 있다.
  * 객체 협력을 위해 다른 객체 필요 &#8594; 두 객체간 의존성 존재
* 의존성의 종류
  * 직접 의존성 direct dependency
  * 간접 의존성 indirect dependenc
* **의존성 전이** : 변경에 의해 영향이 전파될 수도 있다는 `경고`
* **의존성 대상** : 객체/모듈/큰 규모의 실행시스템일수도 있다.


<br>


**컨텍스트 독립성** : `클래스`가 사용될 특정한 `문맥`에 대해 최소한의 가정만으로 이루어져 다른 문맥에서 재사용하기 더 수월해진 것 <br>


* **의존성 해결** : 컴파일타임 의존성을 실행 컨텍스트에 맞는 절적한 런타임 의존성으로 교체하는 것
* 의존성 해결 3가지 방법
  * <u>객체를 생성하는 시점</u>에 **생성자**를 통해서
  * <u>객체 생성 후</u>, **setter 메서드**를 통해서
  * <u>메서드 실행시</u> **인자**를 이용해서

  

* **의존성과 결합도**
  * 의존성은 나쁘다? ❌
  * 바람직한 의존성
    * **재사용성**
    * 컨텍스트에 독립적인 의존성
    * 느슨한 결합도 (loose coupling) = 약한 결합도 (weak coupling)


* 결합의 정도 : 의한하는 두 요서간, 서로에 대해 알고 있는 **지식의 양**


* **추상화** : 어떤 양상/세부사항/구조를 명학하게 이해하기 위해서 특정 절차나 물체를 의조적으로 생략/감춤으로써 복잡도를 극복하는 방법
* 의존하는 대상이 더 추상적일 수록 결합도는 낮아진다.


<br>

> UML과 의존성
> - UML은 두 요소 사이의 관계로 실체화 관계(realization), 연관관계(association), 의존관계(dependency), 일반화/특수화 관계(generalization), 합성관계(composition), 집합관계(aggregation) 등을 정의한다.
> - ch8에서 의존성 != UML 의존관계
>   - UML에 정의된 모든관계는 의존성 개념을 포함


  <br>


* "컴파일 타임" 용어를 보면 2가지중 어느것인지 파악 중요
  * 정말 컴파일이 진행되는 시점인지
  * 코드 작성 시점인지
* 객체지향 애플리케이션 - 런타임 주인공 : 객체
  * 런타임 의존성이 다루는 주제 : 객체간의 의존성
  * 컴파일 타임 의존성이 다루는 주제 : 클래스 간의 의존성
* **컴파일타임 의존성을 실행시점에 각각의 인스턴스에 대한 런타임 의존성으로 대체해야 한다**



* **명시적 의존성**
  * 모든 경우에 의존성은 명시적으로 **퍼블릭 인터페이스에 노출**된다.


* **new 는 해롭다**
  * 이유
    * 구체 클래스에 이름을 직접 기술 → 구체클래스 의존(추상화X)
    * 클라이언트가 알아야 하는 지식의 양도 늘어난다. (어떤 인자를 이용해 클래스 생성자를 호출해야 하는지) → 결합도 ⬆
  * 인스턴스 생성하는 로직과 생성된 인스턴스를 사용하는 로직 분리


* 표준 클래스에 대한 의존은 해롭지 않다
  * 의존성 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다.

  ``` java
  public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();
    
    public void switchConditions(List<DiscountCondition> conditions) {
      this.conditions = conditions;
    }
  }
  ```
  
<br>


* **컨텍스트 확장하기**
  * 생성자 체이닝 기법으로 기본값을 null로 할당하여 할인정책이 적용되지 않게 한 경우 
    * Movie와 DiscountPolicy 사이의 `협력방식에 어긋`나는 `예외케이스`가 추가
  * 해결책
    * 할인 정책이 존재하지 않는다는 사실을 예외 케이스로 처리하지 말고,
    * 기존 Movid와 DiscountPolicy가 협력하던 방식을 따르게 한다.
      * 할인정책이 존재하지 않는다 → 할인 정책의 한 종류로 간주
      * NoneDiscountPolicy 추가

<br>

* **조합 가능한 행동**
  > ... (절차적인 코드를 작성하기 보다 인스턴스 추가나 제거 또는 조합을 달리해서) 시스템의 작동방식을 바꿀 수 있다. <br>
  > ... 시스템을 이런방식으로 구축하면 방법(how)이 아니라 목적(what)에 집중할 수 있어 시스템의 행위를 변경하기가 더 쉽다. <br>
