# Chapter 07. 객체분해

> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; / &nbsp; 조영호 저자 &nbsp; / &nbsp; 위키북스
> * 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)
    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)
    >  * 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
>  * 책의 내용과 다릅니다.
>
## reference
* [저자 조영호 님 github](https://github.com/eternity-oop/object)

## 목표
* 1회독 완독, 설계, 객체지향 프로그래밍 학습
* 2021.08.02 ~ 08.08 : chapter 01 by ksh
* 2021.08.09 ~ 08.15 : chapter 02 by ksh
* 2021.08.16 ~ 08.22 : chapter 03, 04 by ksh
* 2021.08.23 ~ 08.29 : chapter 05 by ksh
* 2021.08.30 ~ 09.12 : chapter 06 by ksh
* 2021.09.13 ~ 09.25 : chapter 07 by ksh


---



#### 요구사항
( 교재는 루비 코드로(루비 1도 몰라요), 최대한 책의 형태를 따르는 방식으로 단계별 프로그래밍 실습과 교재 학습 )

* 직원의 급여를 계산한다.
* 급여 = 기본급 - (기본급*소득세율)

> 사용자로부터 소득세율을 입력받는다. <br>
> - "세율을 입력하세요:" <br>
> - 키보드를 통해 세율을 입력받는다. <br>
> 
> 직원의 급여를 계산한다. <br>
> - 전역 변수에 저장된 직원의 기본급 정보를 얻는다. <br>
> - 급여를 계산한다.  <br>
> 
> 양식에 맞게 결과를 출력한다. <br>
> - 이름: [직원명], 급여 : [계산된 금액]  <br>
> 

p.227 step02
> 급여 관리 시스템에 회사에 속한 모든 직원들의 기본급의 총합을 구하는 기능을 추가해 달라는 요구사항 접수


p.231 step03
* 프로그래밍 하며 교재를 이탈하기 시작...
  * step02에서의 enum을 그대로 두니, 입력값에 대한 검증로직 필요되어 변경
  * Money 로 객체 분리 후 수정 수월
> 정규 직원의 급여뿐만 아니라 아르바이트 직원에 대한 급여 역시 개발된 급여 관리 시스템을 이용해 계산할 수 있게 해달라는 변경요청 <br>
> * 아르바이트 생은 일한 시간에 시급을 곱한 금액만큼을 지급받는다. <br>
> * 급여 계산시 소득세율만큼의 금액을 공제한 후 지급해야 한다.
> 

p.239 step04
* 모듈의 장점과 한계
  * 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
  * 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
  * 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.
* 모듈의 단점
  * 인스턴스의 개념을 제공하지 않는다.
    * 좀더 높은 추상화를 위해서 직원 전체가 아니라 개별 직원을 독립적인 단위로 다를 수 있어야 한다.
      * Employees 안에 name 이 아닌 index 를 이용하도록 변경되어 있다.
        * 이때 name 으로 처리하고 하니, Employee를 만들뻔 했다. ㅎㅎㅎ 
    * 추상 데이터 타입


* step05
  * '직원의 급여를 계산한다'는 절차를 이용한 사고보다는 '직원'과 '금여'라는 추상적 개념들을 이용해 '계산'에 필요한 절차를 생각하게 한다.
  * 데이터를 감춘다
    * 직원 데이터 추상화


* step06
  * 이전 step05 - 추상 데이터타입 사용시 Employee 하나의 타입 안 2가지 직원타입 캡슐화
  * 클래스 이용한 객체지향 - 각 직원 타입 클래스로 구현하여 2개 타입 존재를 명시적으로 표현


<br>


## 01 프로시저 추상화와 데이터 추상화


## 02 프로시저 추상화와 기능 분해


### 02-4. 하향식 기능 분해의 문제점

<br>

#### 1) 하나의 메인 함수라는 비현실적인 아이디어

* 시간이 지나고 사용자를 만족시키기 위한 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다.
* 대부분의 시스템에서 하나의 메인기능이란 개념은 존재하지 않는다.
* 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성된다.

<br>

#### 2) 메인 함수의 빈번한 재설계
* sumOfBasePays 메서드와 같은 새로운 정상을 추가할 때마다 하나의 정상이라고 간주했던 main 함수 내부 구현을 수정해야만 한다.
* 빈번한 수정으로 버그 발생 확률이 높아지고, 시스템은 변경에 취약해 질 것이다.

<br>

#### 3) 비즈니스 로직과 사용자 인터페이스의 결합
* 하향식 접근법은 기능을 분해하는 과정에서 사용자 인터페이스의 관심사와 비즈니스 로직의 관심사를 동시에 고려하도록 강요하기 때문에 <u>"관심사의 분리" 라는 아키텍처 설계의 목적을 달성하기 어렵다.</u>
  * 문제는 비즈니스 로직과 사용자 인터페이스의 변경 빈도가 다르기 때문이다.
  * 급여 관리 시스템의 사용자 인터페이스를 GUI 기반으로 변경한다고 가정해 보자.
  > main 함수에 뒤섞여 있기 때문에 사용자 인터페이스를 변경하는 유일한 방법은 전체 구조를 재설계 하는 것뿐이다.
  >

<br>

#### 4) 성급하게 결정된 실행 순서
* ⛔ 하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작게 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다.
  * 하향식 접근법의 설계는 처음부터 구현을 염두 하기 때문에 <u>함수들의 실행 순서를 정의하는 시간 제약(temporal constraint)을 강조한다.</u>
  * 하향식 설계와 관련된 모든 문제의 원인은 **결합도**이다.
* **해결하려면**
  * 시간적인 제약은 버리고 좀더 안정적인 논리적 제약(logical constraint)을 설계의 기준으로 삼는다.


#### 5) 데이터 변경으로 인한 파급효과
* 하향식 기능 분해의 문제
  * 의존성과 결합도의 문제이고, 테스트의 문제이다.

* 실습 - 아르바이트 직원 급여계산에 추가
  * 정규직 직원/아르바이트 직원 index로 구별위한 배열 데이터 추가
  * 정규직이 아닌 아르바이트 직원의 업무시간 기록 데이터 추가
  * 직원의 기본급 총합 로직시 데이터 중 아르바이트 직원 제외 로직으로 변경
    * 실제 작업에서는 3번째의 분석이 완벽하지 않을 경우 버그 발생 확률이 높을 것이다.
    * 보통 변수 추가로 함수가 수정될걸 예측하지 쉽지 않다.
    * 라인 수가 증가할수록 전역 데이터를 변경하는 것은 악몽으로 변해간다.


✔ 의존성 관리의 핵심
* **변경에 대한 영향을 최소화**


#### 6) 언제 하향식 분해가 유용한가?
p.235 문제점들 정리...


<br>


## 03. 모듈

#### 정보은닉은 외부에 감추기 위해 시스템을 분할하는 모듈 분할 원리이다.
* 비밀 결정하고 모듈 분해 후, 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.
* 모듈이 감춰야 하는 2가지 비밀
  * 복잡성
  * 변경 가능성
* '비밀' 이란 일반적으로 데이터일 뿐, 복잡한 로직이나 변경 가능성이 큰 자료구조일 수도 있다.
* step04
  * 급여관리시스템에서 비밀은? 직원정보 p.236


#### 정보은닉 != 데이터 캡슐화
* 데이터 캡슐화 data encapsulation
  * 데이터와 메서드를 하나의 단위로 통합하고 퍼블릭 메서드를 통해서만 접근하도록 허용시키는 방법
  * 비밀의 한 종류로 데이터를 감추는 캡슐화의 한 종류

#### JAVA 모듈? 패키지 package  [ref](https://baobabnamu.github.io/java/module/package/university-java-pkg-mod/)
* JAVA 9 이후 자바 API를 쪼개 99개의 모듈 파일에 나누어 저장함 -> 컴퓨터 시스템의 부담 감소
  * JRE의 lib 밑에 Modules 모듈 저장, 프로그램 실행 시 modules 파일에서 필요한 모듈, 클래스만 로딩
    * JAVA 8 까지 : JRE가 실행되는 컴퓨터에 rt.jar(용량 큼) 설치
  * 맞춤형 실행 환경 조성 가능,
    jlink 명령을 프로그램에 필요한 모듈들로만 실행 환경 구축이 가능해져 메모리가 열악한 소형기기도 실행 가능


* 모듈의 단점 : 인스턴스의 개념을 제공하지 않는다.

<br>


## 04. 데이터 추상화와 추상 데이터 타입
* 다양한 형태의 내장타입 built-in type 제공
  > 프로시저 추상화로는 프로그램으 표현력을 향상시키는데 한계가 있다는 사실을 발견했다. <br>
  > **바바라 리스코프**는 데이터의 추상화 개념을 제안 ...<br>
  > 추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.이것은 오퍼레이션을 이용해 추상 데이터 타입을 정의할 수 있음을 의미한다...
  > <br> .. 추상 데이터 객체로 행위이 구현 정보는 오직 오퍼레이션을 어떻게 구현할 것인지에 집중할 때만 필요하기 때문에 객체 사용자는 외부에 제공하는 행위에만 관심 가진다.
  >

<br>


## 05 클래스
#### 05-1 클래스는 추상 데이터 타입인가?

추상 데이터 타입과 클래스는 동일하지 않다.

윌리엄 쿡 William Cook , Object Oriented Programming Versus Abstract Data Types
> 프로그래밍 언어적인 관점에서, 추상데이터 타입은 타입을 추상화한 것(type abstraction)이고 클래스는 절차를 추상화한 것(procedural abstraction) 이다.
>